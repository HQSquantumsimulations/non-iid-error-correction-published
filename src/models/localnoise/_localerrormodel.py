import functools
import math
import numpy as np
import qecsim
from qecsim import paulitools as pt
from qecsim.model import cli_description
from qecsim.models.generic import SimpleErrorModel
from qecsim.models.generic import BiasedDepolarizingErrorModel


@cli_description('Non-uniform Pauli error model')
class LocalErrorModel(SimpleErrorModel):
    """
        Generates errors according to local error probabilities (px, py, pz) generated by
        :meth:'qubit_error_probabilities' of :class:'LocalCode'.
    """

    def generate(self, code, probability, rng):
        """
        Generates X,Y,Z errors according to :meth:'qubit_error_probabilities' of :class:'LocalCode'
        Returns generated errors in the bsf format
        """
        rng = np.random.default_rng()  # seed for random error generation
        n_qubits = code.n_k_d[0]  # number of qubits in the code
        Pxyz = code.qubit_error_probabilities()  # generates array of (px, py, pz) for each qubit
        error_pauli_size = np.zeros((2 * code.size[0] - 1, 2 * code.size[1] - 1), dtype='str')
        ep = ['I'] * n_qubits
        error_pauli = ""
        for row, col in np.ndindex(error_pauli_size.shape):  # generates errors at each qubit according to Pxyz
            index = (row, col)
            if code.is_site(index):
                local_prob = self.single_qubit_error_prob(Pxyz[0, row, col], Pxyz[1, row, col], Pxyz[2, row, col], probability)
                qubit_error = rng.choice(('I', 'X', 'Y', 'Z'), p=local_prob)
                q = self.flatten_site_index(code, index)
                ep[q] = qubit_error
                error_pauli = error_pauli + qubit_error
        error = ''.join(ep)
        return pt.pauli_to_bsf(error)

    @functools.lru_cache()
    def single_qubit_error_prob(self, p_x, p_y, p_z, p):
        """For a given qubit returns error probabilities normalized on a total error probability p"""
        p_i = 1 - p * (p_x + p_y + p_z)
        return p_i, p * p_x, p * p_y, p * p_z

    def flatten_site_index(self, code, index):
        """Return 1-d index from 2-d index for internal storage."""
        r, c = index
        assert code.is_site(index), 'Invalid site index: {}.'.format(index)
        assert code.is_in_bounds(index), 'Out of bounds index: {}.'.format(index)
        rows, cols = code.size
        flatten_index = (r // 2) * (cols - c % 2) + (c // 2) + (r % 2 * rows * cols)
        return flatten_index

    @functools.lru_cache()
    def probability_distribution(self, probability):
        """See :meth:`qecsim.model.ErrorModel.probability_distribution`"""
        p_x = p_y = p_z = probability / 3
        return 1 - sum((p_x, p_y, p_z)), p_x, p_y, p_z

    @functools.lru_cache()
    def label(self):
        """See :meth:`qecsim.model.ErrorModel.label`"""
        error_label = 'Non-uniform Pauli error model'
        return error_label


@cli_description('Effective MMHH error model')
class ErrorModelMMHHLayout(SimpleErrorModel):
    """
        Effective error model for simulating the MMHH code using the CSS code.
        Instead of Clifford-deforming the code stabilizers, applies identical deformations to errors locally.
        Using the known error rates, permutes Pauli errors at each qubit such that
        (CSS code + effective error mode) is identical to (MMHH code + random local model).
        To be used in conjunction with the CSS code.
    """

    def generate(self, code, probability, rng):
        """
        Generates X,Y,Z according to :meth:'qubit_error_mmhh_layout' of :class:'LocalCode'
        Returns permuted generated errors in the bsf format
        """
        rng = np.random.default_rng()
        n_qubits = code.n_k_d[0]
        Pxyz = code.qubit_error_mmhh_layout()
        error_pauli_size = np.zeros((2 * code.size[0] - 1, 2 * code.size[1] - 1), dtype='str')
        ep = ['I'] * n_qubits
        error_pauli = ""
        # Generate error for each qubit according to Pxyz
        for row, col in np.ndindex(error_pauli_size.shape):
            index = (row, col)
            if code.is_site(index):
                local_prob = self.single_qubit_error_prob(Pxyz[0, row, col], Pxyz[1, row, col], Pxyz[2, row, col], probability)
                qubit_error = rng.choice(('I', 'X', 'Y', 'Z'), p=local_prob)
                q = self.flatten_site_index(code, index)
                ep[q] = qubit_error
                error_pauli = error_pauli + qubit_error
        error = ''.join(ep)
        return pt.pauli_to_bsf(error)

    @functools.lru_cache()
    def single_qubit_error_prob(self, p_x, p_y, p_z, p):
        # normalized probabilities
        p_i = 1 - p * (p_x + p_y + p_z)
        return p_i, p * p_x, p * p_y, p * p_z

    def flatten_site_index(self, code, index):
        """Return 1-d index from 2-d index for internal storage."""
        r, c = index
        assert code.is_site(index), 'Invalid site index: {}.'.format(index)
        assert code.is_in_bounds(index), 'Out of bounds index: {}.'.format(index)
        rows, cols = code.size
        flatten_index = (r // 2) * (cols - c % 2) + (c // 2) + (r % 2 * rows * cols)
        return flatten_index

    @functools.lru_cache()
    def probability_distribution(self, probability):
        """See :meth:`qecsim.model.ErrorModel.probability_distribution`"""
        p_x = p_y = p_z = probability / 3
        p_i = 1 - sum((p_x, p_y, p_z))
        return p_i, p_x, p_y, p_z

    @functools.lru_cache()
    def label(self):
        """See :meth:`qecsim.model.ErrorModel.label`"""
        error_label = 'Effective local error model'
        return error_label
