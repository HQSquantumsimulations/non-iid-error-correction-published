import functools
import itertools
import operator
import math
import numpy as np
from scipy.stats import truncnorm
from qecsim.model import StabilizerCode, cli_description
from qecsim.models.planar import PlanarCode

@cli_description('Planar Local (rows INT >= 2, cols INT >= 2)')
class LocalCode(PlanarCode):
    """
      Implements a locally Clifford-deformed planar mixed boundary code defined by its lattice size.

      In addition to the members defined in :class:`PlanarCode`, it provides several methods described below.

      Error probabilities and stabilizers:

      Error probabilities are different for each qubit and generated by :meth:'qubit_error_probabilities'.
      :meth:'qubit_error_probabilities':
      1) used to generate local error probabilities
      2) called by :meth:'generate' of :class:'LocalErrorModel' and used to generate errors
      3) called by :meth:'plaquette' of :class:'PlanarPauli' and used to construct non-CSS codes from the CSS code
      """

    MIN_SIZE = (2, 2)

    def __init__(self, rows, columns, mean, std, seed_h=1, seed_m=2, seed_l=3, seed_n=4, nonuniform=True, std_t=0.0):
        """
        Initialise new planar code.

        :param rows: Number of rows in lattice.
        :type rows: int
        :param columns: Number of columns in lattice.
        :type columns: int
        :param mean: Mean value of Pauli error rates.
        :type mean: float
        :param std: Standard deviation of Pauli error rates.
        :type std: float
        :param std_t: Standard deviation of total error rates.
        :type rows: float
        :param nonuniform: turns on or off non-uniformity in total error rates.
        :type nonuniform: bool
        :param seed_h, seed_m, seed_l, seed_n: seeds for random generation of errors for each qubit.
        :raises ValueError: if (rows, columns) smaller than (2, 2) in either dimension.
        :raises TypeError: if any parameter is of an invalid type.
        """
        super().__init__(rows, columns)
        min_rows, min_cols = self.MIN_SIZE
        try:  # paranoid checking for CLI. (operator.index ensures the parameter can be treated as an int)
            if operator.index(rows) < min_rows or operator.index(columns) < min_cols:
                raise ValueError('{} minimum size is {}.'.format(type(self).__name__, self.MIN_SIZE))
            if not (mean >= 0 and math.isfinite(mean) and std >= 0 and math.isfinite(std)):
                raise ValueError('{} valid mean and std of error model are number >= 0'.format(type(self).__name__))
        except TypeError as ex:
            raise TypeError('{} invalid parameter type'.format(type(self).__name__)) from ex
        self._size = rows, columns
        self._std = std
        self._mean = mean
        self._seed_h = seed_h
        self._seed_m = seed_m
        self._seed_l = seed_l
        self._seed_nonuniform = seed_n
        self._nonuniform = nonuniform
        self._std_total = std_t
    # < StabilizerCode interface methods >

    @functools.lru_cache(maxsize=2 ** 28)
    def qubit_error_probabilities(self):
        """
        Generates array of error probabilities for each individual qubit
        Returns: Pxyz = {p_x, p_y, p_z} for each qubit (NOTE: normalized on 1)
        """

        # First, we generate error probabilities on large surface-code lattice of the size (n_max, m_max)
        n_max = 2 * 155 - 1
        m_max = 2 * 155 - 1
        assert 2 * self.size[0] - 1 < n_max, 'Increase n_max'
        assert 2 * self.size[1] - 1 < m_max, 'Increase m_max'

        # Step 1: generate probabilities of Pauli X, Y, and Z errors for each qubit
        myclip_a = 0.001  # Truncate normal distribution at 0.001 and 0.999
        myclip_b = 0.999
        std = self._std
        mean = self._mean
        a, b = (myclip_a - mean) / std, (myclip_b - mean) / std
        np.random.seed(self._seed_l)
        Px_max = truncnorm.rvs(a, b, loc=mean, scale=std, size=(n_max, m_max))  # generate probabilities of Pauli X
        np.random.seed(self._seed_m)
        Py_max = truncnorm.rvs(a, b, loc=mean, scale=std, size=(n_max, m_max))  # generate probabilities of Pauli Y
        np.random.seed(self._seed_h)
        Pz_max = truncnorm.rvs(a, b, loc=mean, scale=std, size=(n_max, m_max))  # generate probabilities of Pauli Z

        # Step 2: generate total error probabilities p = px + py + pz for each qubit
        # Truncate normal distribution at 0.001 and 0.999; centered at 1:
        myclip_at = 0.001
        myclip_bt = 1.999
        std_t = self._std_total
        mean = 1.0
        a, b = (myclip_at - mean) / std_t, (myclip_bt - mean) / std_t
        np.random.seed(self._seed_nonuniform)
        density_max = truncnorm.rvs(a, b, loc=mean, scale=std_t, size=(n_max, m_max))

        # Generate codes of different distances by 'cutting' smaller codes from the large one generated above
        # This way a distance (d+1) code contains a distance d code as its sublattice
        n = 2 * self.size[0] - 1
        m = 2 * self.size[1] - 1
        Px = Px_max[0:n, 0:m]
        Py = Py_max[0:n, 0:m]
        Pz = Pz_max[0:n, 0:m]
        density = density_max[0:n, 0:m]
        Pxyz = np.zeros((3, n, m), dtype=float)

        # Normalize error probabilities on uniform or non-uniform distribution
        for row, col in np.ndindex(Pxyz[0, :, :].shape):
            index = (row, col)
            if self.is_site(index):
                Pxyz[0, row, col], Pxyz[1, row, col], Pxyz[2, row, col] = self.normalize_error_probs(Px[row, col], Py[row, col], Pz[row, col])
                if self._nonuniform:
                    Pxyz[0, row, col], Pxyz[1, row, col], Pxyz[2, row, col] = self.generate_nonuniform(Pxyz[0, row, col], Pxyz[1, row, col], Pxyz[2, row, col], density[row, col])
        return Pxyz

    @functools.lru_cache(maxsize=2 ** 28)
    def normalize_error_probs(self, px, py, pz):
        """Normalize error probabilities for each qubit on 1"""
        Px = px / (px + py + pz)
        Py = py / (px + py + pz)
        Pz = pz / (px + py + pz)
        return Px, Py, Pz

    @functools.lru_cache(maxsize=2 ** 28)
    def generate_nonuniform(self, px, py, pz, density):
        """Normalize an error probability of a given qubit on the total error probability of that qubit"""
        Px = px * density
        Py = py * density
        Pz = pz * density
        return Px, Py, Pz

    @property
    def label(self):
        """See :meth:`qecsim.model.StabilizerCode.label`"""
        return 'Clifford-deformed {}x{} code'.format(*self.size)